---
- name: Install required packages for management node
  apt:
    name:
      - ansible
      - python3
      - python3-pip
      - jq
      - git
      - curl
      - vim
      - wget
      - wireguard
      - rsync # Add rsync to the package list
    state: present
    update_cache: yes
  become: true

- name: Set hostname based on inventory name (if valid format)
  block:
    - name: Generate valid hostname from inventory_hostname
      set_fact:
        valid_hostname: "{{ inventory_hostname | replace('_', '-') }}"

    - name: Set hostname
      hostname:
        name: "{{ valid_hostname }}"
      become: true

    - name: Update /etc/hosts with proper hostname
      lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.1\.1\s+.*$'
        line: "127.0.1.1 {{ valid_hostname }}"
        state: present
      become: true

- name: Update /etc/hosts with proper hostname
  lineinfile:
    path: /etc/hosts
    regexp: '^127\.0\.1\.1\s+.*$'
    line: "127.0.1.1 {{ inventory_hostname }}"
    state: present
  become: true

- name: Install kubectl
  shell: |
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    sudo mv kubectl /usr/local/bin/
  args:
    creates: /usr/local/bin/kubectl
  become: true

- name: Install Helm
  shell: |
    curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
  args:
    creates: /usr/local/bin/helm
  become: true

- name: Ensure target directory exists on management node
  file:
    path: "~/tfgrid-k3s"
    state: directory
    mode: "0755"

- name: Synchronize entire tfgrid-k3s directory to management node
  synchronize:
    src: "{{ playbook_dir }}/../" # Assuming playbook_dir points to roles/management/tasks
    dest: "~/tfgrid-k3s/"
    delete: yes # Remove files that don't exist in source
    rsync_opts:
      - "--exclude=.git"
      - "--exclude=*.retry"
      - "--exclude=node_modules"
      - "--exclude=.terraform"
      - "--exclude=.terraform.lock.hcl"
      - "--exclude=.vscode"
      - "--exclude=*.swp"
      - "--exclude=*.swo"
      - "--exclude=__pycache__"
  become: no # Typically better to run rsync as the user who will own the files

- name: Find all shell scripts in tfgrid-k3s
  find:
    paths: "{{ ansible_env.HOME }}/tfgrid-k3s"
    patterns: "*.sh"
    recurse: yes
  register: shell_scripts

- name: Debug - show found shell scripts
  debug:
    msg: "Found {{ shell_scripts.files | length }} shell scripts"
  when: shell_scripts.files | length > 0

- name: Set executable permissions on all shell scripts
  file:
    path: "{{ item.path }}"
    mode: "0755"
  with_items: "{{ shell_scripts.files }}"
  when: shell_scripts.files | length > 0

- name: Validate directory structure
  shell: ls -la ~/tfgrid-k3s/
  register: dir_listing
  changed_when: false

- name: Show directory contents
  debug:
    var: dir_listing.stdout_lines

- name: Check if kubeconfig file exists
  stat:
    path: "{{ playbook_dir }}/../k3s.yaml"
  register: kubeconfig_file
  delegate_to: localhost

- name: Ensure .kube directory exists
  file:
    path: "~/.kube"
    state: directory
    mode: "0700"

- name: Copy kubeconfig to management node
  copy:
    src: "{{ playbook_dir }}/../k3s.yaml"
    dest: ~/.kube/config
    mode: "0600"
  when: kubeconfig_file.stat.exists | default(false)
  register: kubeconfig_copied

- name: Update kubeconfig server address
  replace:
    path: ~/.kube/config
    regexp: "https://127.0.0.1:6443"
    replace: 'https://{{ hostvars[primary_control_node | default("node1")]["ansible_host"] }}:6443'
  when: kubeconfig_copied is defined and kubeconfig_copied.changed

- name: Debug and fix kubeconfig
  block:
    - name: Check kubeconfig content
      shell: cat ~/.kube/config
      register: kubeconfig_content
      changed_when: false
      ignore_errors: true

    - name: Show kubeconfig server value
      debug:
        msg: "Current kubeconfig server value: {{ kubeconfig_content.stdout | regex_search('server: (.+)', '\\1') | first | default('not found') }}"
      when: kubeconfig_content.rc is defined and kubeconfig_content.rc == 0

    - name: Get control node IP
      debug:
        msg: "Control node IP should be: {{ hostvars[primary_control_node | default('node1')]['ansible_host'] }}"

    - name: Update kubeconfig server address again
      replace:
        path: ~/.kube/config
        regexp: "server: https://127.0.0.1:6443"
        replace: 'server: https://{{ hostvars[primary_control_node | default("node1")]["ansible_host"] }}:6443'
      register: kubeconfig_updated
      ignore_errors: true

    - name: Show kubeconfig update status
      debug:
        msg: "Kubeconfig was {{ 'updated' if kubeconfig_updated.changed else 'already correct or not found' }}"
  become: true

- name: Display message if kubeconfig doesn't exist yet
  debug:
    msg: "Kubeconfig file doesn't exist yet. It will be created later in the deployment process."
  when: not kubeconfig_file.stat.exists | default(false)

- name: Install k9s for improved Kubernetes UX
  block:
    - name: Get latest k9s release version
      uri:
        url: https://api.github.com/repos/derailed/k9s/releases/latest
        return_content: yes
      register: k9s_latest_release
      failed_when: false # Don't fail the whole playbook if GitHub API is down

    - name: Set k9s version (latest or fallback)
      set_fact:
        k9s_version: "{{ k9s_latest_release.json.tag_name | default('v0.28.0') }}"

    - name: Download k9s
      get_url:
        url: "https://github.com/derailed/k9s/releases/download/{{ k9s_version }}/k9s_Linux_amd64.tar.gz"
        dest: "/tmp/k9s.tar.gz"
        mode: "0644"
        timeout: 60
      register: k9s_download
      retries: 3
      delay: 5
      until: k9s_download is succeeded

    - name: Create temporary directory for k9s extraction
      file:
        path: /tmp/k9s_extract
        state: directory
        mode: "0755"

    - name: Extract k9s
      unarchive:
        src: /tmp/k9s.tar.gz
        dest: /tmp/k9s_extract
        remote_src: yes

    - name: Move k9s binary to /usr/local/bin
      copy:
        src: /tmp/k9s_extract/k9s
        dest: /usr/local/bin/k9s
        mode: "0755"
        remote_src: yes

    - name: Create k9s config directory
      file:
        path: ~/.config/k9s
        state: directory
        mode: "0700"

    - name: Configure k9s with sensible defaults
      copy:
        dest: ~/.config/k9s/config.yml
        content: |
          # K9s Configuration - Auto-generated for Kubernetes management
          k9s:
            refreshRate: 2
            headless: false
            readOnly: false
            noIcons: false
            logger:
              tail: 100
              buffer: 5000
            currentContext: default
            currentCluster: default
            clusters:
              default:
                namespace:
                  active: default
                  favorites:
                    - default
                    - kube-system
                    - ingress-nginx
                view:
                  active: pods
                featureGates:
                  nodeShell: false
                shellPod:
                  image: busybox:1.35.0
                  command: []
                  args: []
                  namespace: default
                  limits:
                    cpu: 100m
                    memory: 100Mi
        mode: "0600"

    - name: Clean up temporary files
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /tmp/k9s.tar.gz
        - /tmp/k9s_extract
  become: true
  ignore_errors: yes # Continue with other tasks even if k9s installation fails

- name: Set up unified kubectl and k9s configuration in shell profile
  blockinfile:
    path: "/root/.bashrc"
    marker: "# {mark} KUBERNETES TOOLS CONFIGURATION"
    block: |
      # Set up kubectl to work without manual configuration
      export KUBECONFIG=/root/.kube/config

      # Useful aliases
      alias k=kubectl
      alias k9s='k9s --readonly=false --logoless'

      # Display cluster info on login
      if [ -f "$KUBECONFIG" ]; then
        echo "Kubernetes cluster information:"
        kubectl cluster-info 2>/dev/null || echo "Cluster not accessible yet"
        echo ""
        echo "Management Tools Available:"
        echo "  - kubectl: Run 'kubectl get nodes' to see cluster nodes"
        if command -v k9s >/dev/null 2>&1; then
          echo "  - k9s: Run 'k9s' to launch the interactive Kubernetes TUI"
          echo "    • Press '?' in k9s for help and keyboard shortcuts"
          echo "    • Press 'Ctrl+A' in k9s to access command menu"
          echo "    • Press 'Esc' to go back or exit a view"
        fi
      fi
    create: yes
  become: true
